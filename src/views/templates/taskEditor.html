<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Task Editor</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
        color: var(--vscode-foreground);
        background-color: var(--vscode-editor-background);
        margin: 0;
        padding: 0;
        height: 100vh;
        line-height: 1.4;
        font-size: 13px;
      }

      .container {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      /* Tab navigation */
      .tab-nav {
        position: sticky;
        top: 0;
        z-index: 10;
        background-color: var(--vscode-editor-background);
        border-bottom: 1px solid var(--vscode-panel-border);
        display: flex;
        overflow-x: auto;
      }

      .tab-item {
        padding: 12px 20px;
        cursor: pointer;
        color: var(--vscode-foreground);
        opacity: 0.8;
        font-size: 13px;
        white-space: nowrap;
        position: relative;
      }

      .tab-item.active {
        opacity: 1;
        font-weight: 600;
      }

      .tab-item.active::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 2px;
        background-color: var(--vscode-focusBorder);
      }

      .tab-item:hover:not(.active) {
        opacity: 1;
        background-color: var(--vscode-list-hoverBackground);
      }

      /* Content area */
      .content-container {
        flex: 1;
        overflow-y: auto;
        padding: 24px 32px;
      }

      .settings-section {
        margin-bottom: 40px;
        scroll-margin-top: 50px; /* Ensures that when scrolled to, it appears below the tabs */
      }

      .settings-content-header {
        font-size: 26px;
        font-weight: 600;
        margin-bottom: 25px;
        color: var(--vscode-foreground);
        line-height: 1.2;
      }

      .settings-section-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--vscode-settings-headerForeground);
        margin-bottom: 12px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--vscode-settings-headerBorder);
      }

      .settings-section-description {
        font-size: 13px;
        color: var(--vscode-foreground);
        margin-bottom: 16px;
        line-height: 1.4;
      }

      .setting-item {
        margin-bottom: 24px;
      }

      .setting-item-label {
        font-weight: 600;
        margin-bottom: 4px;
        color: var(--vscode-foreground);
      }

      .setting-item-description {
        font-size: 12px;
        color: var(--vscode-descriptionForeground);
        margin-bottom: 8px;
        line-height: 1.4;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 4px 8px;
        font-size: 13px;
        color: var(--vscode-input-foreground);
        background-color: var(--vscode-input-background);
        border: 1px solid var(--vscode-input-border);
        border-radius: 2px;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: 1px solid var(--vscode-focusBorder);
        border-color: transparent;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .checkbox-wrapper input[type="checkbox"] {
        width: 16px;
        height: 16px;
        margin: 0;
      }

      button {
        padding: 6px 14px;
        font-size: 13px;
        font-weight: 600;
        border: none;
        border-radius: 2px;
        cursor: pointer;
        background-color: var(--vscode-button-background);
        color: var(--vscode-button-foreground);
      }

      button.secondary {
        background-color: var(--vscode-button-secondaryBackground);
        color: var(--vscode-button-secondaryForeground);
      }

      button:hover {
        background-color: var(--vscode-button-hoverBackground);
      }

      button.secondary:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
      }

      .array-item {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 8px;
        margin-bottom: 8px;
        align-items: center;
      }

      .action-buttons {
        background-color: var(--vscode-editor-background);
        margin-top: 24px;
        padding: 16px 0;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        border-top: 1px solid var(--vscode-panel-border);
      }

      /* Custom VS Code style scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
      }

      ::-webkit-scrollbar-track {
        background: var(--vscode-scrollbarSlider-background);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--vscode-scrollbarSlider-hoverBackground);
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--vscode-scrollbarSlider-activeBackground);
      }

      /* Custom select button styles */
      .select-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        width: 100%;
      }

      .select-wrapper select {
        flex: 1;
      }

      .custom-input-btn {
        margin-left: 8px;
        padding: 4px 6px;
        font-size: 11px;
        background-color: var(--vscode-button-secondaryBackground);
        color: var(--vscode-button-secondaryForeground);
        border-radius: 2px;
        cursor: pointer;
        white-space: nowrap;
      }

      .custom-input-btn:hover {
        background-color: var(--vscode-button-secondaryHoverBackground);
      }

      .custom-input-container {
        display: none;
        margin-top: 8px;
      }

      .custom-input-container.active {
        display: block;
      }

      .nested-property {
        margin-left: 20px;
        position: relative;
      }

      .nested-property::before {
        content: "";
        position: absolute;
        left: -12px;
        top: 0;
        height: 100%;
        width: 1px;
        background-color: var(--vscode-panel-border);
      }

      .nested-property::after {
        content: "";
        position: absolute;
        left: -12px;
        top: 12px;
        width: 8px;
        height: 1px;
        background-color: var(--vscode-panel-border);
      }

      .property-path {
        font-size: 11px;
        color: var(--vscode-descriptionForeground);
        margin-bottom: 4px;
      }

      .property-type-selector {
        margin-top: 4px;
        margin-bottom: 8px;
        display: flex;
        gap: 8px;
      }

      .property-type-selector button {
        padding: 2px 8px;
        font-size: 11px;
      }

      .additional-property-container {
        margin-bottom: 16px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--vscode-panel-border);
      }

      .additional-property-container:last-child {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Tab Navigation -->
      <div class="tab-nav">
        <div class="tab-item active" data-section="basic-section">Basic</div>
        <div class="tab-item" data-section="execution-section">Execution</div>
        <div class="tab-item" data-section="presentation-section">
          Presentation
        </div>
        <div class="tab-item" data-section="dependencies-section">
          Dependencies
        </div>
        <div class="tab-item" data-section="advanced-section">Advanced</div>
        <div class="tab-item" data-section="additional-section">
          Additional Properties
        </div>
      </div>

      <!-- Content Container -->
      <div class="content-container">
        <form id="taskForm">
          <!-- Basic Settings Section -->
          <div id="basic-section" class="settings-section">
            <div class="settings-content-header">Basic Configuration</div>

            <div class="settings-section-description">
              Configure the core properties of your task including its name,
              type, and the command to execute.
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="taskLabel"
                >Task Label</label
              >
              <div class="setting-item-description">
                A short name that identifies this task in the tasks list.
              </div>
              <input type="text" id="taskLabel" required />
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="taskType">Task Type</label>
              <div class="setting-item-description">
                Specifies how the task should be executed.
              </div>
              <div class="select-wrapper">
                <select id="taskType" required>
                  <option value="shell">Shell</option>
                  <option value="npm">npm</option>
                  <option value="typescript">TypeScript</option>
                  <option value="grunt">Grunt</option>
                  <option value="gulp">Gulp</option>
                  <option value="jake">Jake</option>
                </select>
                <button
                  type="button"
                  class="custom-input-btn"
                  onclick="toggleCustomInput('taskType')"
                >
                  Custom
                </button>
              </div>
              <div id="taskType-custom" class="custom-input-container">
                <input
                  type="text"
                  id="taskType-custom-input"
                  placeholder="Enter custom task type"
                />
              </div>
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="command">Command</label>
              <div class="setting-item-description">
                The command to execute.
              </div>
              <input type="text" id="command" required />
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="detail"
                >Detail/Description</label
              >
              <div class="setting-item-description">
                Additional information about this task shown in the tasks list.
              </div>
              <input type="text" id="detail" />
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="isBackground" />
                <label for="isBackground" class="setting-item-label"
                  >Run in Background</label
                >
              </div>
              <div class="setting-item-description">
                Run the task in the background without blocking other tasks.
              </div>
            </div>
          </div>

          <!-- Execution Settings Section -->
          <div id="execution-section" class="settings-section">
            <div class="settings-content-header">Execution Options</div>

            <div class="settings-section-title">Shell Options</div>
            <div class="settings-section-description">
              Configure how the shell should behave when executing this task.
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="shellExecutable"
                >Shell Executable</label
              >
              <div class="setting-item-description">
                The path to the shell executable to use (e.g., bash, cmd.exe,
                powershell).
              </div>
              <input
                type="text"
                id="shellExecutable"
                placeholder="e.g., bash, cmd.exe, powershell"
              />
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="shellArgs"
                >Shell Arguments</label
              >
              <div class="setting-item-description">
                Arguments to pass to the shell executable (e.g., -c, /C).
              </div>
              <input type="text" id="shellArgs" placeholder="e.g., -c, /C" />
            </div>

            <div class="settings-section-title">
              Working Directory & Environment
            </div>
            <div class="setting-item">
              <label class="setting-item-label" for="cwd"
                >Working Directory</label
              >
              <div class="setting-item-description">
                The directory from which the task command should be executed.
                Use ${workspaceFolder} to reference the workspace root.
              </div>
              <input
                type="text"
                id="cwd"
                placeholder="${workspaceFolder}/subfolder"
              />
            </div>

            <div class="setting-item">
              <label class="setting-item-label">Environment Variables</label>
              <div class="setting-item-description">
                Define environment variables that will be available to the task.
              </div>
              <div id="envVars"></div>
              <button type="button" class="secondary" onclick="addEnvVar()">
                Add Environment Variable
              </button>
            </div>

            <div class="settings-section-title">Problem Matchers</div>
            <div class="setting-item">
              <div class="setting-item-description">
                Problem matchers scan the task output and highlight errors and
                warnings.
              </div>
              <div class="array-item">
                <select id="problemMatcherSelect">
                  <option value="$tsc">TypeScript ($tsc)</option>
                  <option value="$eslint-compact">
                    ESLint ($eslint-compact)
                  </option>
                  <option value="$jshint">JSHint ($jshint)</option>
                  <option value="$jshint-stylish">
                    JSHint Stylish ($jshint-stylish)
                  </option>
                  <option value="$node">Node ($node)</option>
                  <option value="$npm">npm ($npm)</option>
                  <option value="$gulp-tsc">Gulp TypeScript ($gulp-tsc)</option>
                  <option value="$msCompile">
                    MSBuild/Visual Studio ($msCompile)
                  </option>
                  <option value="$lessCompile">Less ($lessCompile)</option>
                  <option value="$sass-compile">Sass ($sass-compile)</option>
                </select>
                <button
                  type="button"
                  class="secondary"
                  onclick="addProblemMatcher()"
                >
                  Add
                </button>
              </div>
              <div id="problemMatchers" class="problem-matchers"></div>
            </div>
          </div>

          <!-- Presentation Settings Section -->
          <div id="presentation-section" class="settings-section">
            <div class="settings-content-header">Presentation Options</div>
            <div class="settings-section-description">
              Configure how task output is presented in the terminal.
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="reveal"
                >Terminal Reveal</label
              >
              <div class="setting-item-description">
                Controls when the terminal should be revealed when this task
                runs.
              </div>
              <div class="select-wrapper">
                <select id="reveal">
                  <option value="always">Always</option>
                  <option value="silent">Silent</option>
                  <option value="never">Never</option>
                </select>
                <button
                  type="button"
                  class="custom-input-btn"
                  onclick="toggleCustomInput('reveal')"
                >
                  Custom
                </button>
              </div>
              <div id="reveal-custom" class="custom-input-container">
                <input
                  type="text"
                  id="reveal-custom-input"
                  placeholder="Enter custom reveal value"
                />
              </div>
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="panel"
                >Panel Behavior</label
              >
              <div class="setting-item-description">
                Controls which terminal panel to use for task output.
              </div>
              <div class="select-wrapper">
                <select id="panel">
                  <option value="shared">Shared</option>
                  <option value="dedicated">Dedicated</option>
                  <option value="new">New</option>
                </select>
                <button
                  type="button"
                  class="custom-input-btn"
                  onclick="toggleCustomInput('panel')"
                >
                  Custom
                </button>
              </div>
              <div id="panel-custom" class="custom-input-container">
                <input
                  type="text"
                  id="panel-custom-input"
                  placeholder="Enter custom panel value"
                />
              </div>
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="group"
                >Terminal Group</label
              >
              <div class="setting-item-description">
                Group that this terminal belongs to.
              </div>
              <input type="text" id="group" placeholder="e.g., build" />
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="echo" />
                <label for="echo" class="setting-item-label"
                  >Echo Command</label
                >
              </div>
              <div class="setting-item-description">
                Controls whether the command is echoed in the terminal before
                execution.
              </div>
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="focus" />
                <label for="focus" class="setting-item-label"
                  >Focus Terminal</label
                >
              </div>
              <div class="setting-item-description">
                Controls whether the terminal should be focused after task
                execution starts.
              </div>
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="clear" />
                <label for="clear" class="setting-item-label"
                  >Clear Terminal Before Execution</label
                >
              </div>
              <div class="setting-item-description">
                Controls whether the terminal is cleared before executing the
                task.
              </div>
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="showReuseMessage" />
                <label for="showReuseMessage" class="setting-item-label"
                  >Show Terminal Reuse Message</label
                >
              </div>
              <div class="setting-item-description">
                Controls whether to show the terminal reuse message when reusing
                a terminal.
              </div>
            </div>
          </div>

          <!-- Dependencies Settings Section -->
          <div id="dependencies-section" class="settings-section">
            <div class="settings-content-header">Task Dependencies</div>
            <div class="settings-section-description">
              Configure which tasks need to be run before this task.
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="dependsOrder"
                >Dependency Execution Order</label
              >
              <div class="setting-item-description">
                Specifies whether dependencies should be run in sequence or in
                parallel.
              </div>
              <select id="dependsOrder">
                <option value="sequence">Sequential</option>
                <option value="parallel">Parallel</option>
              </select>
            </div>

            <div class="setting-item">
              <label class="setting-item-label">Task Dependencies</label>
              <div class="setting-item-description">
                Tasks that need to be run before this task.
              </div>
              <div id="dependencies"></div>
              <button type="button" class="secondary" onclick="addDependency()">
                Add Dependency
              </button>
            </div>
          </div>

          <!-- Advanced Settings Section -->
          <div id="advanced-section" class="settings-section">
            <div class="settings-content-header">Advanced Options</div>
            <div class="settings-section-description">
              Configure additional advanced task options.
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="taskGroup"
                >Task Group</label
              >
              <div class="setting-item-description">
                The task group this task belongs to. Tasks can be run as part of
                a group.
              </div>
              <select id="taskGroup">
                <option value="">None</option>
                <option value="build">Build</option>
                <option value="test">Test</option>
              </select>
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="groupIsDefault" />
                <label for="groupIsDefault" class="setting-item-label"
                  >Set as Default Task for Group</label
                >
              </div>
              <div class="setting-item-description">
                Sets this task as the default task for its group.
              </div>
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="runOn">Run On</label>
              <div class="setting-item-description">
                Controls when this task should be run.
              </div>
              <select id="runOn">
                <option value="default">Default</option>
                <option value="folderOpen">Folder Open</option>
              </select>
            </div>

            <div class="setting-item">
              <div class="checkbox-wrapper">
                <input type="checkbox" id="reevaluateOnRerun" />
                <label for="reevaluateOnRerun" class="setting-item-label"
                  >Re-evaluate on Rerun</label
                >
              </div>
              <div class="setting-item-description">
                Controls whether variable substitution should be reevaluated
                when a task is rerun.
              </div>
            </div>

            <div class="setting-item">
              <label class="setting-item-label" for="instanceLimit"
                >Instance Limit</label
              >
              <div class="setting-item-description">
                Limits the number of concurrent executions of this task.
              </div>
              <input type="number" id="instanceLimit" min="1" placeholder="1" />
            </div>
          </div>

          <!-- Additional Properties Section -->
          <div id="additional-section" class="settings-section">
            <div class="settings-content-header">Additional Properties</div>
            <div class="settings-section-description">
              Add custom task properties or override existing properties with
              custom values. You can add nested properties by using dot notation
              in the property name (e.g., "options.customOption").
            </div>

            <div id="additionalProperties"></div>
            <button
              type="button"
              class="secondary"
              onclick="addAdditionalProperty()"
            >
              Add Custom Property
            </button>
          </div>

          <div class="action-buttons">
            <button type="button" class="secondary" onclick="cancelEdit()">
              Cancel
            </button>
            <button type="submit" class="primary">Save Task</button>
          </div>
        </form>
      </div>
    </div>

    <script>
      const vscode = acquireVsCodeApi();
      let problemMatchers = [];
      let envVars = new Map();
      let dependencies = [];

      // Get elements
      const tabItems = document.querySelectorAll(".tab-item");
      const sections = document.querySelectorAll(".settings-section");
      const contentContainer = document.querySelector(".content-container");

      // Tab click handler - smooth scroll to section
      tabItems.forEach((tab) => {
        tab.addEventListener("click", () => {
          const sectionId = tab.getAttribute("data-section");
          const section = document.getElementById(sectionId);

          // Scroll to section
          contentContainer.scrollTo({
            top: section.offsetTop - 48, // Adjust for tab height
            behavior: "smooth",
          });
        });
      });

      // Scroll spy functionality
      contentContainer.addEventListener("scroll", () => {
        const scrollPosition = contentContainer.scrollTop;

        // Find the current visible section
        let currentSectionId = sections[0].id;

        sections.forEach((section) => {
          const sectionTop = section.offsetTop;

          if (scrollPosition >= sectionTop - 100) {
            currentSectionId = section.id;
          }
        });

        // Update active tab
        tabItems.forEach((tab) => {
          if (tab.getAttribute("data-section") === currentSectionId) {
            tab.classList.add("active");
          } else {
            tab.classList.remove("active");
          }
        });
      });

      function addProblemMatcher() {
        const select = document.getElementById("problemMatcherSelect");
        const matcher = select.value;
        if (!problemMatchers.includes(matcher)) {
          problemMatchers.push(matcher);
          updateProblemMatchersList();
        }
      }

      function removeProblemMatcher(matcher) {
        problemMatchers = problemMatchers.filter((m) => m !== matcher);
        updateProblemMatchersList();
      }

      function updateProblemMatchersList() {
        const container = document.getElementById("problemMatchers");
        container.innerHTML = "";
        problemMatchers.forEach((matcher) => {
          const div = document.createElement("div");
          div.className = "array-item";
          div.innerHTML = `
            <span>${matcher}</span>
            <button type="button" class="secondary" onclick="removeProblemMatcher('${matcher}')">Remove</button>
          `;
          container.appendChild(div);
        });
      }

      function addEnvVar() {
        const envVarsContainer = document.getElementById("envVars");
        const id = Date.now().toString();

        const div = document.createElement("div");
        div.className = "array-item";
        div.innerHTML = `
          <input type="text" placeholder="Variable name" class="env-key" data-id="${id}">
          <input type="text" placeholder="Value" class="env-value" data-id="${id}">
          <button type="button" class="secondary" onclick="removeEnvVar('${id}')">Remove</button>
        `;

        envVarsContainer.appendChild(div);
        envVars.set(id, { key: "", value: "" });

        const keyInput = div.querySelector(".env-key");
        const valueInput = div.querySelector(".env-value");

        keyInput.addEventListener("input", (e) => {
          const pair = envVars.get(id);
          envVars.set(id, { ...pair, key: e.target.value });
        });

        valueInput.addEventListener("input", (e) => {
          const pair = envVars.get(id);
          envVars.set(id, { ...pair, value: e.target.value });
        });
      }

      function removeEnvVar(id) {
        const element = document.querySelector(
          `.array-item input[data-id="${id}"]`,
        ).parentNode;
        element.remove();
        envVars.delete(id);
      }

      function addDependency() {
        const container = document.getElementById("dependencies");
        const id = Date.now().toString();

        const div = document.createElement("div");
        div.className = "array-item";
        div.innerHTML = `
          <input type="text" placeholder="Task name" class="dep-task" data-id="${id}">
          <select class="dep-type" data-id="${id}">
            <option value="">Task name only</option>
            <option value="npm">npm</option>
            <option value="shell">shell</option>
            <option value="typescript">typescript</option>
          </select>
          <button type="button" class="secondary" onclick="removeDependency('${id}')">Remove</button>
        `;

        container.appendChild(div);
        dependencies.push({ id, task: "", type: "" });

        const taskInput = div.querySelector(".dep-task");
        const typeSelect = div.querySelector(".dep-type");

        taskInput.addEventListener("input", (e) => {
          const index = dependencies.findIndex((d) => d.id === id);
          if (index !== -1) {
            dependencies[index].task = e.target.value;
          }
        });

        typeSelect.addEventListener("change", (e) => {
          const index = dependencies.findIndex((d) => d.id === id);
          if (index !== -1) {
            dependencies[index].type = e.target.value;
          }
        });
      }

      function removeDependency(id) {
        const element = document.querySelector(
          `.array-item input[data-id="${id}"]`,
        ).parentNode;
        element.remove();
        dependencies = dependencies.filter((d) => d.id !== id);
      }

      function cancelEdit() {
        vscode.postMessage({ type: "cancel" });
      }

      document.getElementById("taskForm").addEventListener("submit", (e) => {
        e.preventDefault();

        // Convert envVars Map to object
        const envVarsObject = {};
        envVars.forEach((value) => {
          if (value.key) {
            envVarsObject[value.key] = value.value;
          }
        });

        // Convert dependencies array to proper format
        const formattedDeps = dependencies
          .filter((dep) => dep.task)
          .map((dep) => {
            if (dep.type) {
              return { type: dep.type, task: dep.task };
            }
            return dep.task;
          });

        const taskGroup = document.getElementById("taskGroup").value;
        const groupData = taskGroup
          ? {
              kind: taskGroup,
              isDefault: document.getElementById("groupIsDefault").checked,
            }
          : undefined;

        const taskData = {
          label: document.getElementById("taskLabel").value,
          type: document.getElementById("taskType").value,
          command: document.getElementById("command").value,
          detail: document.getElementById("detail").value || undefined,
          isBackground: document.getElementById("isBackground").checked,

          options: {
            cwd: document.getElementById("cwd").value || undefined,
            env:
              Object.keys(envVarsObject).length > 0 ? envVarsObject : undefined,
            shell: {
              executable:
                document.getElementById("shellExecutable").value || undefined,
              args: document.getElementById("shellArgs").value
                ? document
                    .getElementById("shellArgs")
                    .value.split(",")
                    .map((arg) => arg.trim())
                : undefined,
            },
          },

          presentation: {
            echo: document.getElementById("echo").checked,
            reveal: document.getElementById("reveal").value,
            focus: document.getElementById("focus").checked,
            panel: document.getElementById("panel").value,
            showReuseMessage:
              document.getElementById("showReuseMessage").checked,
            clear: document.getElementById("clear").checked,
            group: document.getElementById("group").value || undefined,
          },

          problemMatcher:
            problemMatchers.length > 0 ? problemMatchers : undefined,
          group: groupData,
          dependsOn: formattedDeps.length > 0 ? formattedDeps : undefined,
          dependsOrder: document.getElementById("dependsOrder").value,

          runOptions: {
            reevaluateOnRerun:
              document.getElementById("reevaluateOnRerun").checked,
            runOn: document.getElementById("runOn").value,
            instanceLimit: document.getElementById("instanceLimit").value
              ? parseInt(document.getElementById("instanceLimit").value)
              : undefined,
          },
        };

        // Process additional properties
        const additionalProps = processAdditionalProperties();

        // Merge additional properties into the task data
        const finalTaskData = mergeAdditionalProperties(
          taskData,
          additionalProps,
        );

        // Send the task data to the extension
        vscode.postMessage({ type: "save", task: cleanObject(finalTaskData) });
      });

      function processAdditionalProperties() {
        const result = {};

        additionalProperties.forEach((propData) => {
          if (!propData.key) return; // Skip properties without a key

          let value;

          switch (propData.type) {
            case "string":
              value = propData.value || "";
              break;

            case "number":
              value = parseFloat(propData.value) || 0;
              break;

            case "boolean":
              value = Boolean(propData.value);
              break;

            case "object":
              value = {};
              propData.children.forEach((childData) => {
                if (childData.key) {
                  value[childData.key] = getValueByType(childData);
                }
              });
              break;

            case "array":
              value = [];
              propData.children.forEach((childData) => {
                value.push(getValueByType(childData));
              });
              break;

            default:
              value = propData.value;
          }

          result[propData.key] = value;
        });

        return result;
      }

      function getValueByType(data) {
        switch (data.type) {
          case "string":
            return data.value || "";
          case "number":
            return parseFloat(data.value) || 0;
          case "boolean":
            return Boolean(data.value);
          case "object":
            const obj = {};
            if (data.children) {
              data.children.forEach((childData) => {
                if (childData.key) {
                  obj[childData.key] = getValueByType(childData);
                }
              });
            }
            return obj;
          case "array":
            const arr = [];
            if (data.children) {
              data.children.forEach((childData) => {
                arr.push(getValueByType(childData));
              });
            }
            return arr;
          default:
            return data.value;
        }
      }

      function mergeAdditionalProperties(taskData, additionalProps) {
        // Create a deep copy of the task data
        const result = JSON.parse(JSON.stringify(taskData));

        // Process each additional property
        for (const [path, value] of Object.entries(additionalProps)) {
          // Handle dot notation paths
          const parts = path.split(".");
          let current = result;

          // Navigate to the appropriate nested object
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!current[part] || typeof current[part] !== "object") {
              current[part] = {};
            }
            current = current[part];
          }

          // Set the value on the final property
          const lastPart = parts[parts.length - 1];
          current[lastPart] = value;
        }

        return result;
      }

      // Handle messages from extension
      window.addEventListener("message", (event) => {
        const message = event.data;
        switch (message.type) {
          case "init":
            if (message.task) {
              // Basic fields
              document.getElementById("taskLabel").value =
                message.task.label || "";
              document.getElementById("taskType").value =
                message.task.type || "shell";
              document.getElementById("command").value =
                message.task.command || "";
              document.getElementById("detail").value =
                message.task.detail || "";
              document.getElementById("isBackground").checked =
                message.task.isBackground || false;

              // Shell options
              if (message.task.options?.shell) {
                document.getElementById("shellExecutable").value =
                  message.task.options.shell.executable || "";
                document.getElementById("shellArgs").value =
                  message.task.options.shell.args?.join(", ") || "";
              }
              document.getElementById("cwd").value =
                message.task.options?.cwd || "";

              // Environment variables
              if (message.task.options?.env) {
                Object.entries(message.task.options.env).forEach(
                  ([key, value]) => {
                    const id = Date.now() + Math.random();
                    envVars.set(id.toString(), { key, value });
                    const envVarsContainer = document.getElementById("envVars");
                    const div = document.createElement("div");
                    div.className = "array-item";
                    div.innerHTML = `
                      <input type="text" value="${key}" class="env-key" data-id="${id}">
                      <input type="text" value="${value}" class="env-value" data-id="${id}">
                      <button type="button" class="secondary" onclick="removeEnvVar('${id}')">Remove</button>
                    `;
                    envVarsContainer.appendChild(div);
                  },
                );
              }

              // Problem matchers
              if (message.task.problemMatcher) {
                problemMatchers = Array.isArray(message.task.problemMatcher)
                  ? message.task.problemMatcher
                  : [message.task.problemMatcher];
                updateProblemMatchersList();
              }

              // Dependencies
              if (message.task.dependsOn) {
                const deps = Array.isArray(message.task.dependsOn)
                  ? message.task.dependsOn
                  : [message.task.dependsOn];
                deps.forEach((dep) => {
                  const id = Date.now() + Math.random();
                  const depData =
                    typeof dep === "string"
                      ? { task: dep, type: "" }
                      : { task: dep.task, type: dep.type };
                  dependencies.push({ id: id.toString(), ...depData });

                  const container = document.getElementById("dependencies");
                  const div = document.createElement("div");
                  div.className = "array-item";
                  div.innerHTML = `
                    <input type="text" value="${depData.task}" class="dep-task" data-id="${id}">
                    <select class="dep-type" data-id="${id}">
                      <option value="">Task name only</option>
                      <option value="npm" ${depData.type === "npm" ? "selected" : ""}>npm</option>
                      <option value="shell" ${depData.type === "shell" ? "selected" : ""}>shell</option>
                      <option value="typescript" ${depData.type === "typescript" ? "selected" : ""}>typescript</option>
                    </select>
                    <button type="button" class="secondary" onclick="removeDependency('${id}')">Remove</button>
                  `;
                  container.appendChild(div);
                });
              }
              document.getElementById("dependsOrder").value =
                message.task.dependsOrder || "sequence";

              // Presentation options
              if (message.task.presentation) {
                document.getElementById("reveal").value =
                  message.task.presentation.reveal || "always";
                document.getElementById("panel").value =
                  message.task.presentation.panel || "shared";
                document.getElementById("group").value =
                  message.task.presentation.group || "";
                document.getElementById("echo").checked =
                  message.task.presentation.echo || false;
                document.getElementById("focus").checked =
                  message.task.presentation.focus || false;
                document.getElementById("clear").checked =
                  message.task.presentation.clear || false;
                document.getElementById("showReuseMessage").checked =
                  message.task.presentation.showReuseMessage || false;
              }

              // Group configuration
              if (message.task.group) {
                document.getElementById("taskGroup").value =
                  message.task.group.kind || "";
                document.getElementById("groupIsDefault").checked =
                  message.task.group.isDefault || false;
              }

              // Run options
              if (message.task.runOptions) {
                document.getElementById("reevaluateOnRerun").checked =
                  message.task.runOptions.reevaluateOnRerun || false;
                document.getElementById("runOn").value =
                  message.task.runOptions.runOn || "default";
                document.getElementById("instanceLimit").value =
                  message.task.runOptions.instanceLimit || "";
              }

              // Additional properties
              initializeAdditionalProperties(message.task);
            }
            break;
        }
      });

      // Custom input handling
      function toggleCustomInput(selectId) {
        const customInputContainer = document.getElementById(
          `${selectId}-custom`,
        );
        customInputContainer.classList.toggle("active");

        // When activating custom input, focus it
        if (customInputContainer.classList.contains("active")) {
          document.getElementById(`${selectId}-custom-input`).focus();
        }
      }

      // Additional properties handling
      let additionalProperties = new Map();

      function addAdditionalProperty() {
        const container = document.getElementById("additionalProperties");
        const id = Date.now().toString();

        const propContainer = document.createElement("div");
        propContainer.className = "additional-property-container";
        propContainer.dataset.id = id;

        propContainer.innerHTML = `
          <div>
            <label class="setting-item-label" for="prop-key-${id}">Property Name/Path</label>
            <div class="setting-item-description">
              Use dot notation for nested properties (e.g., options.myCustomProperty)
            </div>
            <input type="text" id="prop-key-${id}" placeholder="Property name/path" class="prop-key">
          </div>

          <div class="property-type-selector">
            <button type="button" class="secondary property-type-btn" data-type="string" data-id="${id}" onclick="setPropertyType('${id}', 'string')">String</button>
            <button type="button" class="secondary property-type-btn" data-type="number" data-id="${id}" onclick="setPropertyType('${id}', 'number')">Number</button>
            <button type="button" class="secondary property-type-btn" data-type="boolean" data-id="${id}" onclick="setPropertyType('${id}', 'boolean')">Boolean</button>
            <button type="button" class="secondary property-type-btn" data-type="object" data-id="${id}" onclick="setPropertyType('${id}', 'object')">Object</button>
            <button type="button" class="secondary property-type-btn" data-type="array" data-id="${id}" onclick="setPropertyType('${id}', 'array')">Array</button>
          </div>

          <div id="prop-value-container-${id}">
            <!-- Value input will be inserted here dynamically -->
          </div>

          <div style="margin-top: 10px;">
            <button type="button" class="secondary" onclick="removeAdditionalProperty('${id}')">Remove Property</button>
          </div>
        `;

        container.appendChild(propContainer);
        additionalProperties.set(id, {
          key: "",
          type: "string",
          value: "",
          children: new Map(),
        });

        // Set up event listener for property key
        const keyInput = document.getElementById(`prop-key-${id}`);
        keyInput.addEventListener("input", (e) => {
          const propData = additionalProperties.get(id);
          if (propData) {
            propData.key = e.target.value;
            additionalProperties.set(id, propData);
          }
        });

        // Default to string type
        setPropertyType(id, "string");
      }

      function setPropertyType(id, type) {
        // Update the property data
        const propData = additionalProperties.get(id);
        if (!propData) return;

        propData.type = type;

        // Reset value based on type
        switch (type) {
          case "string":
            propData.value = "";
            break;
          case "number":
            propData.value = 0;
            break;
          case "boolean":
            propData.value = false;
            break;
          case "object":
            propData.value = {};
            propData.children = new Map();
            break;
          case "array":
            propData.value = [];
            propData.children = new Map();
            break;
        }

        additionalProperties.set(id, propData);

        // Highlight the selected type button
        const container = document.querySelector(`[data-id="${id}"]`);
        const buttons = container.querySelectorAll(".property-type-btn");
        buttons.forEach((btn) => {
          if (btn.dataset.type === type) {
            btn.style.backgroundColor = "var(--vscode-button-background)";
            btn.style.color = "var(--vscode-button-foreground)";
          } else {
            btn.style.backgroundColor =
              "var(--vscode-button-secondaryBackground)";
            btn.style.color = "var(--vscode-button-secondaryForeground)";
          }
        });

        // Generate the appropriate input for the selected type
        updatePropertyValueInput(id, type);
      }

      function updatePropertyValueInput(id, type) {
        const container = document.getElementById(`prop-value-container-${id}`);
        const propData = additionalProperties.get(id);

        if (!container || !propData) return;

        switch (type) {
          case "string":
            container.innerHTML = `
              <label class="setting-item-label" for="prop-value-${id}">Value</label>
              <input type="text" id="prop-value-${id}" placeholder="Property value" class="prop-value">
            `;
            const stringInput = document.getElementById(`prop-value-${id}`);
            stringInput.value = propData.value || "";
            stringInput.addEventListener("input", (e) => {
              propData.value = e.target.value;
              additionalProperties.set(id, propData);
            });
            break;

          case "number":
            container.innerHTML = `
              <label class="setting-item-label" for="prop-value-${id}">Value</label>
              <input type="number" id="prop-value-${id}" placeholder="0" class="prop-value">
            `;
            const numberInput = document.getElementById(`prop-value-${id}`);
            numberInput.value = propData.value || 0;
            numberInput.addEventListener("input", (e) => {
              propData.value = parseFloat(e.target.value) || 0;
              additionalProperties.set(id, propData);
            });
            break;

          case "boolean":
            container.innerHTML = `
              <div class="checkbox-wrapper">
                <input type="checkbox" id="prop-value-${id}" class="prop-value">
                <label for="prop-value-${id}" class="setting-item-label">Value</label>
              </div>
            `;
            const boolInput = document.getElementById(`prop-value-${id}`);
            boolInput.checked = propData.value || false;
            boolInput.addEventListener("change", (e) => {
              propData.value = e.target.checked;
              additionalProperties.set(id, propData);
            });
            break;

          case "object":
            container.innerHTML = `
              <div class="nested-properties" id="nested-props-${id}">
                <div class="setting-item-description">Object Properties</div>
                <div id="object-children-${id}"></div>
                <button type="button" class="secondary" onclick="addNestedProperty('${id}')">
                  Add Object Property
                </button>
              </div>
            `;
            // Render any existing nested properties
            renderNestedProperties(id);
            break;

          case "array":
            container.innerHTML = `
              <div class="nested-properties" id="nested-props-${id}">
                <div class="setting-item-description">Array Items</div>
                <div id="array-children-${id}"></div>
                <button type="button" class="secondary" onclick="addArrayItem('${id}')">
                  Add Array Item
                </button>
              </div>
            `;
            // Render any existing array items
            renderArrayItems(id);
            break;
        }
      }

      function addNestedProperty(parentId) {
        const parentData = additionalProperties.get(parentId);
        if (!parentData) return;

        const childId = Date.now().toString();
        parentData.children.set(childId, {
          key: "",
          type: "string",
          value: "",
        });

        const container = document.getElementById(
          `object-children-${parentId}`,
        );
        const childElem = document.createElement("div");
        childElem.className = "nested-property";
        childElem.dataset.id = childId;

        childElem.innerHTML = `
          <div class="array-item">
            <input type="text" placeholder="Property name" class="nested-key" data-parent="${parentId}" data-id="${childId}">
            <select class="nested-type" data-parent="${parentId}" data-id="${childId}">
              <option value="string">String</option>
              <option value="number">Number</option>
              <option value="boolean">Boolean</option>
              <option value="object">Object</option>
              <option value="array">Array</option>
            </select>
            <button type="button" class="secondary" onclick="removeNestedProperty('${parentId}', '${childId}')">Remove</button>
          </div>
          <div id="nested-value-${childId}" class="nested-value-container">
            <input type="text" placeholder="Value" class="nested-value" data-parent="${parentId}" data-id="${childId}">
          </div>
        `;

        container.appendChild(childElem);

        // Set up event listeners
        const keyInput = childElem.querySelector(".nested-key");
        keyInput.addEventListener("input", (e) => {
          const childData = parentData.children.get(childId);
          if (childData) {
            childData.key = e.target.value;
            parentData.children.set(childId, childData);
          }
        });

        const typeSelect = childElem.querySelector(".nested-type");
        typeSelect.addEventListener("change", (e) => {
          const childData = parentData.children.get(childId);
          if (childData) {
            childData.type = e.target.value;
            updateNestedValueInput(parentId, childId, e.target.value);
            parentData.children.set(childId, childData);
          }
        });

        const valueInput = childElem.querySelector(".nested-value");
        valueInput.addEventListener("input", (e) => {
          const childData = parentData.children.get(childId);
          if (childData) {
            childData.value = e.target.value;
            parentData.children.set(childId, childData);
          }
        });
      }

      function addArrayItem(parentId) {
        const parentData = additionalProperties.get(parentId);
        if (!parentData) return;

        const childId = Date.now().toString();
        parentData.children.set(childId, {
          index: parentData.children.size,
          type: "string",
          value: "",
        });

        const container = document.getElementById(`array-children-${parentId}`);
        const childElem = document.createElement("div");
        childElem.className = "nested-property";
        childElem.dataset.id = childId;

        childElem.innerHTML = `
          <div class="array-item">
            <span class="property-path">Item ${parentData.children.size}</span>
            <select class="nested-type" data-parent="${parentId}" data-id="${childId}">
              <option value="string">String</option>
              <option value="number">Number</option>
              <option value="boolean">Boolean</option>
              <option value="object">Object</option>
              <option value="array">Array</option>
            </select>
            <button type="button" class="secondary" onclick="removeArrayItem('${parentId}', '${childId}')">Remove</button>
          </div>
          <div id="nested-value-${childId}" class="nested-value-container">
            <input type="text" placeholder="Value" class="nested-value" data-parent="${parentId}" data-id="${childId}">
          </div>
        `;

        container.appendChild(childElem);

        // Set up event listeners
        const typeSelect = childElem.querySelector(".nested-type");
        typeSelect.addEventListener("change", (e) => {
          const childData = parentData.children.get(childId);
          if (childData) {
            childData.type = e.target.value;
            updateNestedValueInput(parentId, childId, e.target.value);
            parentData.children.set(childId, childData);
          }
        });

        // Initialize value input based on type
        updateNestedValueInput(parentId, childId, childData.type);

        index++;
      }

      function updateNestedValueInput(parentId, childId, type) {
        const parentData = additionalProperties.get(parentId);
        if (!parentData) return;

        const childData = parentData.children.get(childId);
        if (!childData) return;

        const container = document.getElementById(`nested-value-${childId}`);

        switch (type) {
          case "string":
            container.innerHTML = `
              <input type="text" placeholder="Value" class="nested-value" data-parent="${parentId}" data-id="${childId}">
            `;
            const stringInput = container.querySelector(".nested-value");
            stringInput.value = childData.value || "";
            stringInput.addEventListener("input", (e) => {
              childData.value = e.target.value;
              parentData.children.set(childId, childData);
            });
            break;

          case "number":
            container.innerHTML = `
              <input type="number" placeholder="0" class="nested-value" data-parent="${parentId}" data-id="${childId}">
            `;
            const numberInput = container.querySelector(".nested-value");
            numberInput.value = childData.value || 0;
            numberInput.addEventListener("input", (e) => {
              childData.value = parseFloat(e.target.value) || 0;
              parentData.children.set(childId, childData);
            });
            break;

          case "boolean":
            container.innerHTML = `
              <div class="checkbox-wrapper">
                <input type="checkbox" id="nested-value-checkbox-${childId}" class="nested-value" data-parent="${parentId}" data-id="${childId}">
                <label for="nested-value-checkbox-${childId}">Value</label>
              </div>
            `;
            const boolInput = container.querySelector(".nested-value");
            boolInput.checked = childData.value || false;
            boolInput.addEventListener("change", (e) => {
              childData.value = e.target.checked;
              parentData.children.set(childId, childData);
            });
            break;

          case "object":
            container.innerHTML = `
              <div class="nested-properties">
                <div class="setting-item-description">Object Properties</div>
                <div id="object-children-${childId}"></div>
                <button type="button" class="secondary" onclick="addSubNestedProperty('${parentId}', '${childId}')">
                  Add Object Property
                </button>
              </div>
            `;
            childData.children = new Map();
            break;

          case "array":
            container.innerHTML = `
              <div class="nested-properties">
                <div class="setting-item-description">Array Items</div>
                <div id="array-children-${childId}"></div>
                <button type="button" class="secondary" onclick="addSubArrayItem('${parentId}', '${childId}')">
                  Add Array Item
                </button>
              </div>
            `;
            childData.children = new Map();
            break;
        }
      }

      function removeNestedProperty(parentId, childId) {
        const parentData = additionalProperties.get(parentId);
        if (!parentData) return;

        parentData.children.delete(childId);

        const childElem = document.querySelector(
          `.nested-property[data-id="${childId}"]`,
        );
        if (childElem) {
          childElem.remove();
        }
      }

      function removeArrayItem(parentId, childId) {
        removeNestedProperty(parentId, childId);

        // Update array indices
        const container = document.getElementById(`array-children-${parentId}`);
        const items = container.querySelectorAll(".nested-property");
        items.forEach((item, index) => {
          const indexSpan = item.querySelector(".property-path");
          if (indexSpan) {
            indexSpan.textContent = `Item ${index + 1}`;
          }
        });
      }

      function removeAdditionalProperty(id) {
        additionalProperties.delete(id);

        const propContainer = document.querySelector(
          `.additional-property-container[data-id="${id}"]`,
        );
        if (propContainer) {
          propContainer.remove();
        }
      }

      function renderNestedProperties(parentId) {
        const parentData = additionalProperties.get(parentId);
        if (
          !parentData ||
          !parentData.children ||
          parentData.children.size === 0
        )
          return;

        const container = document.getElementById(
          `object-children-${parentId}`,
        );
        container.innerHTML = "";

        parentData.children.forEach((childData, childId) => {
          const childElem = document.createElement("div");
          childElem.className = "nested-property";
          childElem.dataset.id = childId;

          childElem.innerHTML = `
            <div class="array-item">
              <input type="text" value="${childData.key}" placeholder="Property name" class="nested-key" data-parent="${parentId}" data-id="${childId}">
              <select class="nested-type" data-parent="${parentId}" data-id="${childId}">
                <option value="string" ${childData.type === "string" ? "selected" : ""}>String</option>
                <option value="number" ${childData.type === "number" ? "selected" : ""}>Number</option>
                <option value="boolean" ${childData.type === "boolean" ? "selected" : ""}>Boolean</option>
                <option value="object" ${childData.type === "object" ? "selected" : ""}>Object</option>
                <option value="array" ${childData.type === "array" ? "selected" : ""}>Array</option>
              </select>
              <button type="button" class="secondary" onclick="removeNestedProperty('${parentId}', '${childId}')">Remove</button>
            </div>
            <div id="nested-value-${childId}" class="nested-value-container">
              <!-- Value input will be added dynamically -->
            </div>
          `;

          container.appendChild(childElem);

          // Set up event listeners
          const keyInput = childElem.querySelector(".nested-key");
          keyInput.addEventListener("input", (e) => {
            childData.key = e.target.value;
            parentData.children.set(childId, childData);
          });

          const typeSelect = childElem.querySelector(".nested-type");
          typeSelect.addEventListener("change", (e) => {
            childData.type = e.target.value;
            updateNestedValueInput(parentId, childId, e.target.value);
            parentData.children.set(childId, childData);
          });

          // Initialize value input based on type
          updateNestedValueInput(parentId, childId, childData.type);
        });
      }

      function renderArrayItems(parentId) {
        const parentData = additionalProperties.get(parentId);
        if (
          !parentData ||
          !parentData.children ||
          parentData.children.size === 0
        )
          return;

        const container = document.getElementById(`array-children-${parentId}`);
        container.innerHTML = "";

        let index = 1;
        parentData.children.forEach((childData, childId) => {
          const childElem = document.createElement("div");
          childElem.className = "nested-property";
          childElem.dataset.id = childId;

          childElem.innerHTML = `
            <div class="array-item">
              <span class="property-path">Item ${index}</span>
              <select class="nested-type" data-parent="${parentId}" data-id="${childId}">
                <option value="string" ${childData.type === "string" ? "selected" : ""}>String</option>
                <option value="number" ${childData.type === "number" ? "selected" : ""}>Number</option>
                <option value="boolean" ${childData.type === "boolean" ? "selected" : ""}>Boolean</option>
                <option value="object" ${childData.type === "object" ? "selected" : ""}>Object</option>
                <option value="array" ${childData.type === "array" ? "selected" : ""}>Array</option>
              </select>
              <button type="button" class="secondary" onclick="removeArrayItem('${parentId}', '${childId}')">Remove</button>
            </div>
            <div id="nested-value-${childId}" class="nested-value-container">
              <!-- Value input will be added dynamically -->
            </div>
          `;

          container.appendChild(childElem);

          // Set up event listeners
          const typeSelect = childElem.querySelector(".nested-type");
          typeSelect.addEventListener("change", (e) => {
            childData.type = e.target.value;
            updateNestedValueInput(parentId, childId, e.target.value);
            parentData.children.set(childId, childData);
          });

          // Initialize value input based on type
          updateNestedValueInput(parentId, childId, childData.type);

          index++;
        });
      }

      function initializeAdditionalProperties(task) {
        // Clear existing additional properties
        additionalProperties = new Map();
        const container = document.getElementById("additionalProperties");
        if (container) {
          container.innerHTML = "";
        }

        // Find custom properties that aren't part of the standard task properties
        const additionalProps = findAdditionalProperties(task);

        // Create UI elements for each additional property
        additionalProps.forEach((prop) => {
          addAdditionalPropertyWithValue(prop.path, prop.value);
        });
      }

      function findAdditionalProperties(task, prefix = "", result = []) {
        // List of standard top-level properties to exclude
        const standardProps = [
          "label",
          "type",
          "command",
          "detail",
          "isBackground",
          "options",
          "presentation",
          "problemMatcher",
          "group",
          "dependsOn",
          "dependsOrder",
          "runOptions",
        ];

        // List of standard nested properties
        const standardNestedProps = {
          options: ["cwd", "env", "shell"],
          "options.shell": ["executable", "args"],
          presentation: [
            "echo",
            "reveal",
            "focus",
            "panel",
            "showReuseMessage",
            "clear",
            "group",
          ],
          group: ["kind", "isDefault"],
          runOptions: ["reevaluateOnRerun", "runOn", "instanceLimit"],
        };

        if (typeof task !== "object" || task === null) {
          return result;
        }

        for (const [key, value] of Object.entries(task)) {
          const path = prefix ? `${prefix}.${key}` : key;

          // Skip standard properties at the root level
          if (!prefix && standardProps.includes(key)) {
            continue;
          }

          // Skip standard nested properties
          if (
            prefix &&
            standardNestedProps[prefix] &&
            standardNestedProps[prefix].includes(key)
          ) {
            continue;
          }

          // Handle objects recursively
          if (
            typeof value === "object" &&
            value !== null &&
            !Array.isArray(value)
          ) {
            findAdditionalProperties(value, path, result);
          } else {
            result.push({ path, value });
          }
        }

        return result;
      }

      function addAdditionalPropertyWithValue(path, value) {
        const container = document.getElementById("additionalProperties");
        const id =
          Date.now().toString() + Math.random().toString(36).substring(2, 9);

        const propContainer = document.createElement("div");
        propContainer.className = "additional-property-container";
        propContainer.dataset.id = id;

        // Determine the type of the value
        let type = typeof value;
        if (Array.isArray(value)) {
          type = "array";
        } else if (type === "object" && value !== null) {
          type = "object";
        }

        propContainer.innerHTML = `
          <div>
            <label class="setting-item-label" for="prop-key-${id}">Property Name/Path</label>
            <div class="setting-item-description">
              Use dot notation for nested properties (e.g., options.myCustomProperty)
            </div>
            <input type="text" id="prop-key-${id}" value="${path}" placeholder="Property name/path" class="prop-key">
          </div>

          <div class="property-type-selector">
            <button type="button" class="secondary property-type-btn" data-type="string" data-id="${id}" onclick="setPropertyType('${id}', 'string')">String</button>
            <button type="button" class="secondary property-type-btn" data-type="number" data-id="${id}" onclick="setPropertyType('${id}', 'number')">Number</button>
            <button type="button" class="secondary property-type-btn" data-type="boolean" data-id="${id}" onclick="setPropertyType('${id}', 'boolean')">Boolean</button>
            <button type="button" class="secondary property-type-btn" data-type="object" data-id="${id}" onclick="setPropertyType('${id}', 'object')">Object</button>
            <button type="button" class="secondary property-type-btn" data-type="array" data-id="${id}" onclick="setPropertyType('${id}', 'array')">Array</button>
          </div>

          <div id="prop-value-container-${id}">
            <!-- Value input will be inserted here dynamically -->
          </div>

          <div style="margin-top: 10px;">
            <button type="button" class="secondary" onclick="removeAdditionalProperty('${id}')">Remove Property</button>
          </div>
        `;

        container.appendChild(propContainer);

        // Initialize property data
        additionalProperties.set(id, {
          key: path,
          type: type,
          value: value,
          children: new Map(),
        });

        // Set up event listener for property key
        const keyInput = document.getElementById(`prop-key-${id}`);
        keyInput.addEventListener("input", (e) => {
          const propData = additionalProperties.get(id);
          if (propData) {
            propData.key = e.target.value;
            additionalProperties.set(id, propData);
          }
        });

        // Set the type and initialize the value input
        setPropertyType(id, type);

        // Set the value after initializing the input
        setTimeout(() => {
          const propData = additionalProperties.get(id);
          if (propData) {
            propData.value = value;

            // Update the UI based on the type
            switch (type) {
              case "string":
                document.getElementById(`prop-value-${id}`).value = value;
                break;

              case "number":
                document.getElementById(`prop-value-${id}`).value = value;
                break;

              case "boolean":
                document.getElementById(`prop-value-${id}`).checked = value;
                break;

              case "object":
                // Handle object properties
                if (value && typeof value === "object") {
                  for (const [key, val] of Object.entries(value)) {
                    const childId =
                      Date.now().toString() +
                      Math.random().toString(36).substring(2, 9);
                    propData.children.set(childId, {
                      key: key,
                      type: typeof val,
                      value: val,
                    });
                  }
                  renderNestedProperties(id);
                }
                break;

              case "array":
                // Handle array items
                if (Array.isArray(value)) {
                  value.forEach((item, index) => {
                    const childId =
                      Date.now().toString() +
                      Math.random().toString(36).substring(2, 9);
                    propData.children.set(childId, {
                      index: index,
                      type: "string",
                      value: item,
                    });
                  });
                  renderArrayItems(id);
                }
                break;
            }

            additionalProperties.set(id, propData);
          }
        }, 10);
      }

      function cleanObject(obj) {
        for (const key in obj) {
          if (obj[key] === null || obj[key] === undefined || obj[key] === "") {
            delete obj[key];
          } else if (typeof obj[key] === "object") {
            cleanObject(obj[key]); // Recursively clean nested objects
            // Remove empty objects
            if (Object.keys(obj[key]).length === 0) {
              delete obj[key];
            }
          }
        }
        return obj;
      }

      function mergeAdditionalProperties(taskData, additionalProps) {
        // Create a deep copy of the task data
        const result = JSON.parse(JSON.stringify(taskData));

        // Process each additional property
        for (const [path, value] of Object.entries(additionalProps)) {
          // Handle dot notation paths
          const parts = path.split(".");
          let current = result;

          // Navigate to the appropriate nested object
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!current[part] || typeof current[part] !== "object") {
              current[part] = {};
            }
            current = current[part];
          }

          // Set the value on the final property
          const lastPart = parts[parts.length - 1];
          current[lastPart] = value;
        }

        return result;
      }
    </script>
  </body>
</html>
